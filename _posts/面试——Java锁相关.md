

#### 需要锁的场景：
定义了一个对象，然后线程池多个线程开始调用，那么，这个对象就需要加锁

#### synchronized

synchronized是不公平锁，在进入等待队列前会先自旋尝试获取锁，这步是有可能直接提前获取锁的

synchronized是java提供的原子性内置锁，也被称为监视器锁。会在编译后的 需要同步的代码 前后加上monitorenter和monitorexit，意思是监控开始，监控结束。 

执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。

执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。


依赖操作系统内层的互斥锁实现。


#### 锁的优化机制

包括自适应锁，自旋锁，锁消除，锁粗化，轻量级锁和偏向锁

**自旋锁**：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，**用户态和内核态**的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就**是啥也不干**，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，**自旋的默认次数是10次**，可以使用-XX:PreBlockSpin设置。

**自适应锁**：自适应锁就是**自适应的自旋锁**，自旋的时间不是固定时间，而是**由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。**

**锁消除**：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。

**锁粗化**：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。

**偏向锁**：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。
             是一种无竞争锁

**轻量级锁**：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。

锁的状态从低到高依次为**无锁->偏向锁->轻量级锁->重量级锁**，升级的过程就是从低到高，降级在一定条件也是有可能发生的。

偏向锁就是通过对象头的偏向线程id来对比，都不需要CAS
轻量级锁就是通过CAS来改变头锁记录和自旋来实现
重量级锁是除了拥有锁的线程，其他全部阻塞


#### 对象都包含哪些内容？

对象在内存中包含3个部分
1、对象头(相当于对象的key)
2、实例数据（对象的value）
3、对齐填充（使数据大小符合二进制？）

对象头则分为两部分，数组多一个长度部分
1、markword,对象自身运行的基础数据，包含，轻量级锁指针，重量级锁指针，偏向锁时间戳，偏向锁线程id，对象的hashcode,分代年龄，GC标记
2、存储类型指针，通过这个指针才能确定对象是哪个类的实例

#### Reentrantlock
区别：
1、不会死锁。时间长了可放弃，这个线程转而去处理其他任务，不会出现死锁
2、R可以切换公平锁。都是非公平锁（公平锁：锁的顺序是按照请求顺序来的），但是reentrantlock是可以配置成公平锁的
3、只能修饰代码块，而syn还可以修饰方法
4、reentrantlock需要显性的加锁和释放锁，不想synchronized一样完成后自动解锁
5、底层实现，syn是操作系统底层的monitor实现，reen基于api接口，AQS抽象队列同步器（内置一个cas锁，来修改锁状态，点到为止）

#### CAS的原理

compare and swap比较和交换
没有version字段的乐观锁，只能比较value前后是否有变化，一旦变回来再变回去它就不行了

#### 可重入锁（递归锁）

指外层函数有锁的情况下，内层函数可以获得锁住的代码，synchronized和reentrantlock都是可重入锁。