---
layout:     post
title:      字符流和字节流概念深入
date:       2018-04-17
author:     yunzhs
header-img: img/Fate of Princess.jpg
catalog: true
tags:
    - 随笔
typora-root-url: ..
typora-copy-images-to: ..\img\posts

---

### 1.字符**（Byte）**和字节**（Character）**的概念

- **1 byte = 8 bit**
- **1 char = 2 byte = 16 bit** (Java默认UTF-16编码)

### **2.ASCII**

原本对于西方世界来讲，可能根本用不到“字符”这个东西。1个字节就解决全部问题了。因为一个字节8 bit，最多

为![2^{8}=256 ](https://www.zhihu.com/equation?tex=2%5E%7B8%7D%3D256+)个符号编码。英语26个字母，再加几个常用符号，标点，256个码位足够了。这就熟悉的**ASCII码**

。如下图，ASCII码一共收录了空格及94个“可印刷字符”。每个字母或标点占一个字节。简简单单一个表，就把所

有编码都解决了。

![img](https://pic2.zhimg.com/80/14783261726133ba5b1c8e4d531204f9_hd.jpg)

### 3.**ISO/IEC 8859-1**

但西方世界不光只有英语一门语言。什么德语，法语，西班牙语都有自己的特殊字母。但这也没什么大不了的。每

个国家都可以定义属于自己语言的特殊编码标准，而且大小照样不超过256。因为么大不了的。每个国家都可以定

义属于自己语言的特殊编码标准，而且大小照样不超过256。因为一系列8位字符集。其中最常见的**ISO/IEC 8859-**

**1**就是法语，芬兰语所用的西欧字符集。也是每个字母或符号用1个字节表示，下面这张表解决战斗。

![img](https://pic3.zhimg.com/80/v2-f228f590f4b129f786ca8e8390d4a7fb_hd.jpg)

### 4.**中文编码**

但26个字母到了中文，日语，韩语为代表的东亚象形文字面前就太小儿科了。汉字少说也有十万个。别说是8 bit，就算是16 bit（![2^{16} =65536](https://www.zhihu.com/equation?tex=2%5E%7B16%7D+%3D65536)）也不一定够。如果说一个汉字代表一个**“字**符”，从这个时候开始，“字符”的概念开始凌驾于“字节”之上了。收到的每一个字节不能简单地解码成一个字母了，而是需要好几个字节组合成一个“汉字”。我国的汉字编码现行标准是GB**18030**，每个字可以由1个、2个或4个字节组成，编码空间有161万个字符。另一个中国常用编码集是Big5。

### 5.**Unicode**

在出现Unicode之前，几乎每一种文字都有一套自己的编码方式。同一段**“字节流”**，在美帝可能在出现Unicode之前，几乎每一种文字都有一套自己的编码方式。同一段**“字节流”**，在美帝可能趋。它的理念非常简单：**全世界每个不同语言的不同字符都统一编码，全球通行**。最初，每个字符占用2个字节，总共![2^{16} =65536](https://www.zhihu.com/equation?tex=2%5E%7B16%7D+%3D65536)个字符空间。从第四版开始加入的“扩展字符集”开始使用4个字节（32 bit）编码。目前Unicode收录的字符规模大概在12万左右。

### 6.**UTF-16**

编码里最容易搞混的一件事就是：**Unicode只是一套符号的编码。但计算机具体怎么读取这套编**码，又是另外一件事。

比如既然Unicode常规字符集占用2个字节，系统可以每次老老实实读取两个字节。然后用一个特殊符号告诉系统某个字符属于附加字符集，需要再往后读2个字节。

### 7.**UTF-8** 

但上面UTF-16的缺点也很明显：英文编码也得用两个字节来编写。

考虑到英语是使用最广泛的语言，用2个字节为1字节信息编码，浪费了内存空间。最好是让英语保持ASCII的编码，用1个字节，汉字等其他字符才用2个或更长的字节表示。这里就涉及到一个技术问题：**怎么让系统知道一个字符是用1个还是2个还是3个字节编码的呢？**这就是UTF-8做的事。

如下图所示，这里UTF-8可变长编码用到了一个小技巧：**用几位冗余信息告诉系统，当前字符有没**有结束，是不是还需要继续往下读下一个字节。

![img](https://pic2.zhimg.com/80/v2-56902b3d5bab5827e33fc0040471769a_hd.jpg)

可以看到如果一个字节是**以“0”开头**的，说明是一个ASCII字符，只占一个字节。如果是**“11”开头**的，说明这个字符占用多个字节。后续每个“10”打头的字节都是这个字符的一部分。

**总而言之，一切都是字节流，其实没有字符流这个东西。字符只是根据编码集对字节流翻译之后的产物。**

### 8.**Java I/O的编码系统**

Java IO库有两个支系，

- 面向字节流的**InputStream**和**OutputStream**
- 面向字符的**Reader**和**Writer**

字节流的InputStream和OutputStream是一切的基础。实际总线中流动的只有字节流。需要对字节流做特殊解码才能得到字符流。Java中负责从字节流向字符流解码的桥梁是：

> **InputStreamReader**

> **InputStreamWriter**

根据上面的编码规则，Reader返回的是一个解码后的Unicode码元。包装在一个int整型里返回。

```
abstract int read();
```

也就是收到3个字节后，去掉UTF-8报头，拼装起来得到一个字的Unicode码元。

然后包装在4个字节的int整型里返回：

write()方法是一个相反的编码过程：

```
abstract void write(int c);
```

输入一个Unicode码元的int型，如果设定编码是UTF-8，内部会自动切割并添加报头。

