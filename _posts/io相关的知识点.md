
主要为了方便理解io多路复用技术，因此讲一下其他的io模型

### 1.同步阻塞IO-BIO

在线程处理中，如果涉及到io操作，当前的线程就会被阻塞，直至io处理完成，线程才开始继续执行
![[Pasted image 20230912112810.png]]

实际场景：数据库连接池
缺点：每个客户端都需要新增一个线程，造成线程的频繁切换和阻塞，随之会造成内存空间的压力。

### 2.同步非阻塞IO-NIO

在线程处理中，如果涉及到io操作，那么当前线程不会被阻塞，而是去处理其他业务，等过段时间再去查询io处理是否完成。
![[Pasted image 20230912113518.png]]

实际场景：java的nio,es底层 使用的就是这种机制
缺点：由于需要不停去查，因此cpu压力会很大

### 3.异步非阻塞IO-AIO

相比nio，它没有去查io处理是否完成的动作，而是采用一个回调机制，io处理结束后，去回调原线程。
由于性能上相比之前没有大的提升，因此没有被广泛使用。

实际场景：netty5使用过，实际使用效果很差后下线

我的观点： ==**我觉得这个思路是先进的，无非是难以实现，无法平衡好效能问题**==，想想每个socket都要再配一个发送和接收。。

### 4.IO多路复用

多路：指的是多个socket连接
因此多路复用指的就是：一个线程处理多个socket链接

目前有三种实现方式，分别是==select，poll，epoll==
select和poll基本一致，模式和nio差不多，都是遍历fd（文件描述符）集合，细微区别是select的fd数量最大上限1024

我的观点：==我感觉和nio的底层逻辑是一致的==

epoll是相比是比较先进的，它的fd是有状态的，分为等待和就绪两种状态，而epoll只遍历已就绪的fd，因此所有遍历都是有效的，时间复杂度可以达到o(1)
epoll还有两种工作模式，LT水平触发和ET边缘触发
水平触发：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知
边缘触发：当文件描述符关联的读内核缓冲区发生变化时候，才发出可读信号进行通知，只触发一次

举个例子：  
1.读缓冲区刚开始是空的  
2.读缓冲区写入2KB数据  
3.水平触发和边缘触发模式此时都会发出可读信号  
4.收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据  
5.水平触发会再次进行通知，而边缘触发不会再进行通知

实际使用场景：redis，es，nginx，reactor框架

原文 https://zhuanlan.zhihu.com/p/462924941
