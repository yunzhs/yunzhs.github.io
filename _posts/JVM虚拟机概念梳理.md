---
typora-root-url: ..
typora-copy-images-to: ../img/posts
---

### JVM学习

#### 内存结构：

![image-20210723112304981](/img/posts/image-20210723112304981.png)

程序计数器、虚拟机栈、本地方法、堆、方法区(包含运行时常量池)，jdk8之后变为元数据区

#### 栈 ：

每个方法都会创建一个栈帧，然后每个栈帧下又存以下的信息 ： 

- 局部变量表：存储基本数据类型，对象的引用string和数组(也就是地址)，slot是基本单位，long类型和double类型会占两个，其他一个

- 操作数栈：用于计算的临时数据存储区，比如算数运算的时候，以及调用其他方法时进行参数传递

- 动态链接：指向运行时常量池，当前方法需要调用其他方法的时候能从常量池里取对应的符号应用

- 方法出口: 调用该方法的地址，保证方法执行完毕之后能返回到上层

所以发生栈溢出的情况的话，一般是递归导致的

参数-XSS可以去调整栈的大小

#### 程序计数器：

是当前线程执行字节码文件的行号指示器，线程切换的时候，保证能够恢复到正确的位置

#### 堆：

- 新生代和老年代的默认比例是1:2，一般通过newRatio来进行控制

- eden空间满了进行一次minorGC, 老年代满了会进行majorGC，但是也会执行一次minorGC,从而就是fullGC
- 大对象直接进入老年代
- 类加载器，双亲委派，如果一个类加载器收到加载的请求，他首先不会自己去加载，而是委派给父类，如果父类没有子类才会自己去加载， 用双亲委派主要为了提升效率，减少重复类加载（父类）。也能保证安全性，核心代码不会被替换。

**为什么要设置eden和survivor？**

如果没设置，那么每进行一次minorGC，存活的对象（还有被引用的）就会被送到老年代，从而触发majorGC,这样就会FULL GC 消耗的时间远大于只进行一次minorGC。某种程度上和缓存的机制类似。

因此survivor存在的意义就是减少送到老年代的对象，只有经过**16次**minorGC存活下来的对象，才能获得晋升

- 设置两个survivor的目的：

  解决内存碎片化，能够保证有一个survivor为空，这样就能把碎片的内存地址在新的里面做一个重新的整合

##### GC收集器

- 一般来说，新生代适合性能比较高的收集器，老年代占用空间比较大，次数有限，因此避免使用基于复制算法的GC收集器

- Serial 单线程 parnew多线程。各自对应一个老年代的收集器  还有一个并发的多线程收集器叫Parallel 

jdk1.7，1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.9以后 默认垃圾收集器G1

##### CMS收集器

- CMS是一种以获取最短回收停顿时间为目标的收集器，因此它是可以支持回收线程与用户线程并行的
- CMS基于标记-清除算法，并只用于老年代的回收
- 初始标记->并发标记->重新标记->并发清除。**初始标记**和**重新标记**需要stop on world，初始标记是找能从（GC Roots--存在于stack、方法区，本地的引用）**直接**关联到的对象，并发标记是从root开始找所有关联着的对象，重新标记是修正并发标记期间发生的变动。
- CMS的缺点：
  - 标记-清除算法的弊端，产生大量的内存碎片；
  - 停顿时间是不可控的；
  - 对CPU要求很高
  - 无法处理浮动辣鸡，即用户并行操作产生的产物

> 标记清除算法
>
> 简述原理：程序运行期间，可用内存满了之后，触发GC，这时候标记所有存活的对象，最后把所有没被				   标记的对象清除掉

##### G1收集器

特点：

- 支持并行并发，尽可能的降低stop the world 的时间
- 基于标记-整理算法（1、3、4步均需进行短暂的用户线程暂停）
  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收，前几步与标记-清除大致相同，这步则是把各个region的回收价值和成本进行排序，根据用户期望的GC停顿时间来制定计划，选择符合条件的多个region进行清理，把其中存活的对象放入新的空的region中
- 分代收集
- 可预测的停顿
- 不再分新生代和老年代来区分收集器，新生代默认为5%的region，最大为60%，剩下的归老年代和大对象，**老年代超过45%**就会触发**mixedGC回收**(回收所有年轻代region以及部分老年代region)
  - mixedGC是分段进行的，通过-XX:G1MixedGCCountTarget控制，默认分为8次执行，那么每次STW的时间是25ms。
  - 分次回收主要是用来配合HeapWastePercent=5的，比如第三次回收后空闲region达到堆总内存的5%，那儿就会停止本轮回收，
  - XX:G1MixedGCLiveThresholdPercent=85，默认是85%，只有存活的对象少于85%才能被回收
- 卡表（card table）用于解决老年代引用新生代对象的情况，不用去专门去扫描整个老年代，只需要一个个卡表记录是否有新生代对象的引用，有的话则根据Remembered Set中的记录，找到对应的对象。
- 默认的停顿时间是200ms，region默认个数是2048个，大小为1mb-32mb
- 三色标记：黑灰白，灰色为已标记，但其引用的对象还没有被扫描完
- 安全点和安全区域：确保用户线程暂停，GC线程工作时不会因为gc而导致报错，因此会选择一些地方作为安全点：方法调用、循环跳转、异常跳转等。安全区域则是安全点概念的延伸。
  - gc中断线程采用的是主动式中断而不是抢占式中断，即有一个中断标志，用户线程会不停的主动去轮询这个标志，如果中断，则在离自己安全点上主动挂起
- 漏标问题

![image-20210727155308057](/img/posts/image-20210727155308057.png)

CMS：采用IncrementalUpdate（增量更新）算法，在并发标记阶段时如果一个白色对象被一个黑色对象引用时，会将黑色对象重新标记为灰色，让垃圾收集器在重新标记阶段重新扫描。

G1：采用SATB(snapshot-at-the-beginning)，在初始标记时做一个快照，当B和C之间的引用消失时要把这个引用推到GC的堆栈，保证C还能被GC扫描到，在最终标记阶段扫描STAB记录。



##### ZGC收集器

未来可期，目前仅在jdk11开始支持，停顿时间达到了惊人的亚毫秒级，并且不会随着堆的增大而增大





##### Mataspace（元空间的概念）

- 从java7开始，字符串常量池就从方法区移到了heap里，这是由于string.intern通常是不可预测和不可控的，因此不好设置这个大小。设置不好的话，常常会引起oom

> JDK 1.7后，string.intern()方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。

string.intern()方法举例

```
String str2 = new String("str")+new String("01");
str2.intern();//不存在，在常量池里去创建
String str1 = "str01";
System.out.println(str2==str1);//输出true
```

```
String str2 = new String("str")+new String("01");
String str1 = "str01";
str2.intern();
System.out.println(str2==str1);//输出false，str2指向堆中对象str1指向常量池里的常量故地址不一样
```

- java8的时候则完全去除了permGen(永久代)，将方法区移到了non-heap中的Metaspace中

- Metaspace与原来最大的不同是：Metaspace不存在与java虚拟机中，而是使用本地内存

如果没有设置-XX:MaxMetaspaceSize，则元空间为系统的最大可用内存，达到最大值后可能会让系统把java进程kill掉。

MetaspaceSize参数，是元空间GC发生的最小阈值，他的阈值是在不断变化的，根据实际的使用情况，但不会超过MaxMetaspaceSize