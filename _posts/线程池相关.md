#### 最大线程数与队列

最大线程数与队列的关系，按照最小线程数==》队列==》最大线程数 来增加数量，哪个满了就往下一层增

#### executorService的shutdown()方法

```
executorService.shutdown() 执行后线程池无法再提交任务，且无法恢复
```

shutdown()是正在执行的任务会执行下去，没有被执行的则中断

shutdown()是正在执行的任务被停止，没有被执行的则中断	



#### 使用线程池如何与主线程实现同步

> **问题描述：**
>
> **双重for循环中，内层for循环使用了线程池**
>
> **在这个场景中，线程外的都属于主线程，如果不进行限制，循环内和循环外的应该会同时进行，导致内循环还没完成，外循环就已经完事了**

解决方式：

使用`CountDownLatch`

`new CountDownLatch(threadNum)`初始化线程数，在每个线程的末尾执行countDown()方法，在线程池外调用await()方法，判断计数是否等于0，如果等于0就开始执行主线程，不等于主线程就继续阻塞

```
public void countDown()
```

递减锁存器的计数，如果计数到达零，则释放所有等待的线程。如果当前计数大于零，则将计数减少。如果新的计数为零，出于线程调度目的，将重新启用所有的等待线程。

在线程池外使用

```
public boolean await()
```

使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。如果当前计数为零，则此方法立刻返回 true 值。



#### parallelStream实现并行原理(ForkJoinPool)

parallelStream默认是使用ForkJoinPool线程池来实现的

ForkJoinPool的特点;

- 使用分治算法，用相对少的线程处理大量的任务，将一个大任务一拆为二，以此类推，每个子任务再拆分一半，直至达到最细颗粒度为止。
- 每个线程都有自己的队列，而传统线程池则是共用一个线程池
- 工作窃取模式，队列为双向队列，队列空闲时会从其他队列的尾部窃取任务到头部，实现充分利用cpu的目的

#### 线程池队列类型

- `直接提交`。工作队列的默认选项是 `SynchronousQueue`，它将任务直接提交给线程而不保持它们

- `无界队列`。使用无界队列（例如，不具有预定义容量的 `LinkedBlockingQueue`）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待

- `有界队列`。当使用有限的 maximumPoolSizes 时，有界队列（如 `ArrayBlockingQueue`）有助于防止资源耗尽，但是可能较难调整和控制。
