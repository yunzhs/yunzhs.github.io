---
typora-root-url: ..
typora-copy-images-to: ../img/posts
---

### JVM学习

#### 内存结构：

![image-20210723112304981](/img/posts/image-20210723112304981.png)
JVM内存结构五大块：
程序计数器、
虚拟机栈、
本地方法、
堆、
元数据

#### 栈 ：

每个方法都会创建一个栈帧，然后每个栈帧下又存以下的信息 ： 

- 局部变量表：存储基本数据类型，对象的引用string和数组(也就是地址)，slot是基本单位，long类型和double类型会占两个，其他一个

- 操作数栈：用于计算的临时数据存储区，比如算数运算的时候，以及调用其他方法时进行参数传递

- 动态链接：指向运行时常量池，当前方法需要调用其他方法的时候能从常量池里取对应的符号应用

- 方法出口: 调用该方法的地址，保证方法执行完毕之后能返回到上层

所以发生栈溢出的情况的话，一般是递归导致的

参数-XSS可以去调整栈的大小

#### 程序计数器：

是当前线程执行字节码文件的行号指示器，线程切换的时候，保证能够恢复到正确的位置

#### 堆：

- 新生代和老年代的默认比例是1:2，一般通过newRatio来进行控制

- eden空间满了进行一次minorGC, 老年代满了会进行majorGC，但是也会执行一次minorGC,从而就是fullGC （这是复制算法的老版本）
- 大对象直接进入老年代
- 类加载器，双亲委派，如果一个类加载器收到加载的请求，他首先不会自己去加载，而是委派给父类加载器，如果父类没有子类才会自己去加载， 用双亲委派主要为了，减少重复类加载。也能保证安全性，核心代码不会被替换。
   同时会有打破双亲委派的情况，比如存在不同版本的同名类时，父类的版本不符合要求，需要配置打破双亲委派机制。
   
**为什么年轻代要设置eden和survivor？**

如果没设置，那么每进行一次minorGC，存活的对象（还有被引用的）就会被送到老年代，从而触发majorGC,这样就会FULL GC 消耗的时间远大于只进行一次minorGC。某种程度上和缓存的机制类似。

因此survivor存在的意义就是减少送到老年代的对象，只有经过**16次**minorGC存活下来的对象，才能获得晋升

- 设置两个survivor的目的：

  解决内存碎片化，能够保证有一个survivor为空，这样就能把碎片的内存地址在新的里面做一个重新的整合

##### 老年代分为old和humongous两个区
humongous用于保存大对象，指超过region一半的对象，如果很大可能会分到多个humongous分段上
由于它很大会被优先回收

##### GC收集器

- 一般来说，新生代适合性能比较高的收集器，老年代占用空间比较大，次数有限，因此避免使用基于复制算法的GC收集器

- Serial 单线程 parnew多线程。各自对应一个老年代的收集器  还有一个并发的多线程收集器叫Parallel 

jdk1.7，1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.9以后 默认垃圾收集器G1

##### CMS收集器

- CMS是一种以获取最短回收停顿时间为目标的收集器，因此它是可以支持回收线程与用户线程并行的
- CMS基于标记-清除算法，并只用于老年代的回收
- 初始标记->并发标记->重新标记->并发清除。**初始标记**和**重新标记**需要stop on world，初始标记是找能从（GC Roots--存在于stack、方法区，本地的引用）**直接**关联到的对象，并发标记是从root开始找所有关联着的对象，重新标记是修正并发标记期间发生的变动。
- CMS的缺点：
  - 标记-清除算法的弊端，产生大量的内存碎片；
  - 停顿时间是不可控的；
  - 对CPU要求很高
  - 无法处理浮动辣鸡，即用户并行操作产生的产物

> 标记清除算法
>
> 简述原理：程序运行期间，可用内存满了之后，触发GC，这时候标记所有存活的对象，最后把所有没被标记的对象清除掉

#### G1收集器

##### 标记整理算法：

- 支持并行并发，尽可能的降低stop the world 的时间
- 基于标记-整理算法（1、3、4步均需进行短暂的用户线程暂停）
  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收，前几步与标记-清除大致相同，这步则是把各个region的回收价值和成本进行排序，根据用户期望的GC停顿时间来制定计划，选择符合条件的多个region进行清理，把其中存活的对象放入新的空的region中
##### 特点：
- 分代收集
- 可预测的停顿
- 三种模式，young GC ,mixed GC ，full GC
- 不再分新生代和老年代来区分收集器，新生代默认为5%的region，最大为60%，剩下的归老年代和大对象，**老年代超过45%** 就会触发mixedGC回收(回收所有年轻代region以及部分老年代region)
- mixedGC是分段进行的，通过-XX:G1MixedGCCountTarget控制，默认分为8次执行，那么每次STW的时间是25ms。
- 分次回收主要是用来配合HeapWastePercent=5的，比如第三次回收后空闲region达到堆总内存的5%，那儿就会停止本轮回收，
- XX:G1MixedGCLiveThresholdPercent=85，默认是85%，只有存活的对象少于85%才能被回收
- 卡表（card table）用于解决老年代引用新生代对象的情况，不用去专门去扫描整个老年代，只需要一个个卡表记录是否有新生代对象的引用，有的话则根据Remembered Set(被引用的对象)中的记录，找到对应的对象。
- 默认的停顿时间是200ms，region默认个数是2048个，大小为1mb-32mb


- 三色标记：黑灰白，灰色为已标记，但其引用的对象还没有被扫描完
- 安全点和安全区域：确保用户线程暂停，GC线程工作时不会因为gc而导致报错，因此会选择一些地方作为安全点：方法调用、循环跳转、异常跳转等。安全区域则是安全点概念的延伸。
  - gc中断线程采用的是主动式中断而不是抢占式中断，即有一个中断标志，用户线程会不停的主动去轮询这个标志，如果中断，则在离自己安全点上主动挂起
- 漏标问题

![image-20210727155308057](/img/posts/image-20210727155308057.png)

CMS：采用IncrementalUpdate（增量更新）算法，在并发标记阶段时如果一个白色对象被一个黑色对象引用时，会将黑色对象重新标记为灰色，让垃圾收集器在重新标记阶段重新扫描。

G1：采用SATB(snapshot-at-the-beginning)，在初始标记时做一个快照，当B和C之间的引用消失时要把这个引用推到GC的堆栈，保证C还能被GC扫描到，在最终标记阶段扫描STAB记录。



##### ZGC收集器

未来可期，目前仅在jdk11开始支持，停顿时间达到了惊人的亚毫秒级，并且不会随着堆的增大而增大





##### Mataspace（元空间的概念）

- 从java7开始，字符串常量池就从方法区移到了heap里，这是由于string.intern通常是不可预测和不可控的，因此不好设置这个大小。设置不好的话，常常会引起oom

> JDK 1.7后，string.intern()方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。

string.intern()方法举例

```
String str2 = new String("str")+new String("01");
str2.intern();//不存在，在常量池里去创建
String str1 = "str01";
System.out.println(str2==str1);//输出true
```

```
String str2 = new String("str")+new String("01");
String str1 = "str01";
str2.intern();
System.out.println(str2==str1);//输出false，str2指向堆中对象str1指向常量池里的常量故地址不一样
```

- java8的时候则完全去除了permGen(永久代)，将方法区移到了non-heap中的Metaspace中

- Metaspace与原来最大的不同是：Metaspace不存在与java虚拟机中，而是使用本地内存

如果没有设置-XX:MaxMetaspaceSize，则元空间为系统的最大可用内存，达到最大值后可能会让系统把java进程kill掉。

MetaspaceSize参数，是元空间GC发生的最小阈值，他的阈值是在不断变化的，根据实际的使用情况，但不会超过MaxMetaspaceSize


#### 如何判断一个对象存活？

1、引用计数。2、可达性分析 。主要看第二种

可达性分析主要是通过GC ROOTS通过：
栈中的引用对象
元空间的常量引用
本地方法栈中的对象引用


#### JVM类加载顺序

1、加载，获取类的二进制字节流，将其静态数据结构存储在元空间
2、校验
3、准备，给static变量分配内存，以及给其他变量类型设置默认值
4、解析，将类中的符号与常量池关联
5、初始化，给变量赋上代码中的值


#### JVM三种类加载器
1、启动类加载器，最高级别的父加载器，是jvm的核心类库
2、扩展类加载器，父类是启动类加载器，从jre/lib/ext加载
3、用户程序加载器，用户的，父类扩展类加载器，从环境变量中加载

#### 双亲委派机制
（1）：类加载器收到类加载的请求

（2）：把这个请求委托给父加载器去完成，一直向上委托，直到启动类加载器

（3）：启动器加载器检查能不能加载，能就加载（结束）；否则，抛出异常，通知子加载器进行加载

（4）：保障类的唯一性和安全性以及保证JDK核心类的优先加载，不会出现自定义类覆盖基础类的情况。

#### 双亲委派的缺陷和处理
缺陷：基础类满足不了我们的需求
解决方式：
1、自定义类加载器。
2 SPI(service provider interface),服务提供接口，通过加载ClassPath下META_INF/services，自动加载文件里所定义的类，jdbc就用过这种方法。

#### JVM七种垃圾收集器

（1）、serrial,单线程，复制算法，新生代
（2）：ParNew 复制算法，多线程，新生代

（3）：Parallel Scavenge 多线程，复制算法，新生代，高吞吐量

（4）：Serial Old 标记-整理算法，老年代

（5）：Parallel Old 收集器 标记-整理算法，老年代，注重吞吐量的场景下，jdk8默认采用 Parallel Scavenge + Parallel Old 的组

（6）：CMS 收集器（标记-清除算法，老年代，垃圾回收线程几乎能做到与用户线程同时工作，吞吐量低，内存碎片）以牺牲吞吐量为代价来获得最短回收停顿时间-XX：+UseConcMarkSweepGC jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

（7）G1  多线程，标记-整理算法，通用

### arthas 监控工具

（1）：dashboard命令查看总体jvm运行情况

（2）：jvm显示jvm详细信息
	·
（3）：thread 显示jvm里面所有线程信息（类似于jstack）  查看死锁线程命令thread -b

（4）：sc * 显示所有类（search class）

（5）：trace 跟踪方法


